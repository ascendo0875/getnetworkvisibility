<?php

namespace FINNPartners\Theme\Api;

use FINNPartners\Theme\Api\AbstractClass\AbstractApiController;
use FINNPartners\Theme\Api\ParamsStructure\Event as EventParamStructure;
use FINNPartners\Theme\Api\Repository\EventRepository;
use FINNPartners\Theme\PostType\Register\Event as EventRegisterPostType;
use FINNPartners\Theme\Api\Data\Event as EventData;
use FINNPartners\Theme\Taxonomy\Region;
use FpStructure\Entity\EntityInterface;
use WP_REST_Request;
use WP_REST_Server;

class Event extends AbstractApiController
{
    const FILTER_TYPE_VAR = 'ftype';

    const FILTER_TYPE_UPCOMING = 'upcoming';
    const FILTER_TYPE_UPCOMING_LABEL = 'Upcoming';

    const FILTER_TYPE_PAST = 'past';
    const FILTER_TYPE_PAST_LABEL = 'Past';

    const FILTER_TYPE_DEFAULT = 'upcoming';

    /**
     * @var string
     */
    private $filterType;

    public function __construct(string $paramStructure = EventParamStructure::class)
    {
        parent::__construct($paramStructure);

    }

    public static function url()
    {
        return implode('/', [get_home_url(), "wp-json", self::FP_STRUCTURE_NAMESPACE, EventRegisterPostType::POST_TYPE]);
    }

    /**
     * @return void
     */
    public function rest_api_init(): void
    {
        // TODO: Implement rest_api_init() method.
        register_rest_route(self::FP_STRUCTURE_NAMESPACE, EventRegisterPostType::POST_TYPE, [
            'methods' => WP_REST_Server::READABLE,
            'callback' => [$this, 'getResponse'],
            'permission_callback' => [$this, 'permissionCallBack'],
        ]);
    }

    public function getResponse(WP_REST_Request $request, ?EntityInterface $query = null)
    {
        $this->getParams()->setPostType(EventRegisterPostType::POST_TYPE);
        $this->getParams()->setEntityDataService([EventData::class, 'default']);
        $this->setFilterType($request->get_param(self::FILTER_TYPE_VAR) ?? '');

        if(!empty($request->get_param(Region::TAXONOMY_NAME))) {
            $this->getParams()->setParamsTaxonomy(Region::TAXONOMY_NAME, Region::TAXONOMY_NAME, [
                [
                    'field' => 'slug',
                    'terms' => (!is_array($request->get_param(Region::TAXONOMY_NAME)) ? [$request->get_param(Region::TAXONOMY_NAME)] : $request->get_param(Region::TAXONOMY_NAME))
                ]
            ]);
        }

        if (!empty($request->get_param(self::API_QUERY_SEARCH))) {
            $this->getParams()->setSearchKeywords(self::API_QUERY_SEARCH);
        }

        return parent::getResponse($request, $query); // TODO: Change the autogenerated stub
    }

    protected function query()
    {
        /** @var EventRepository $Repository */
        $Repository = new EventRepository();

        $args = [
            'paged' => $this->getParams()->getPage(),
            'posts_per_page' => $this->getParams()->getPerPage(),
            'post_status' => ['publish'],
            'fields' => 'ids',
            'debug' => false,
            'orderby' => ['start_date' => ($this->getFilterType() === self::FILTER_TYPE_UPCOMING) ? 'ASC' : 'DESC'],
            'meta_query' => [
                ['key' => 'start_date', 'compare' => ($this->getFilterType() === self::FILTER_TYPE_UPCOMING) ? ">=" : "<", "value" => date('Ymd'), "type" => "DATETIME"]
            ]
        ];

        if (!empty($this->getParams()->getParams('meta_query'))) {
            $args = array_merge($args, ['meta_query' => $this->getParams()->getParams('meta_query')]);
        }

        $foundPosts = true;
        $maxNumPages = true;

        $posts = $Repository->findBy($args, $this->getParams(), $foundPosts, $maxNumPages);

        $this->getParams()->setFoundPosts($foundPosts);
        $this->getParams()->setMaxNumPages($maxNumPages);

        return $posts;
    }

    /**
     * @return ?string
     */
    public function getFilterType(): ?string
    {
        return $this->filterType;
    }

    /**
     * @param ?string $filterType
     * @return Event
     */
    public function setFilterType(?string $filterType): Event
    {
        $this->filterType = !empty(trim($filterType)) ? $filterType : self::FILTER_TYPE_DEFAULT;
        return $this;
    }
}